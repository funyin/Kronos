{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Welcome to Kronos. The persistent job scheduling library for kotlin multiplatform.</p>"},{"location":"#summary","title":"Summary","text":"<pre><code>suspend fun main() {\n    //Initialize\n    Kronos.init(\n        mongoConnectionString = \"mongodb://localhost:27017\",\n        redisConnectionString = \"redis://localhost:6379\"\n    )\n    //Register a Job\n    Kronos.register(SayHello)\n    //Schedule a one time job\n    Kronos.schedule(\n        SayHello.name,/*say-hello*/\n        startTime = Instant.now().plusSeconds(60).toEpochMilli(),\n        params = mapOf(\n            \"firsName\" to \"Funyin\",\n            \"lastName\" to \"Kash\"\n        ),\n    )\n\n    //Schedule a periodic job an get back the jobId\n    val jobId = Kronos.schedulePeriodic(\n        jobName = SayHello.name,\n        /*say-hello*/\n//        startTime = Instant.now().plusSeconds(60).toEpochMilli(),\n        periodic = Periodic.everyMinute(),\n//        periodic = Periodic.everyHour(minute = 5),\n//        periodic = Periodic.everyWeek(dayOfWeek = 7, hour = 4, minute = 2),\n//        periodic = Periodic.everyMonth(dayOfMonth = 12, hour = 4, minute = 2),\n//        periodic = Periodic.everyYear(month = 1, dayOfMonth = 7, hour = 4, minute = 2),\n        params = mapOf(\n            \"firsName\" to \"Funyin\",\n            \"lastName\" to \"Kash\"\n        ),\n    )\n\n    //Drop Job By Id\n    jobId?.let { Kronos.dropJobId(it) }\n    //Drop Job By Name\n    jobId?.let { Kronos.dropJob(SayHello.name) }\n\n    Kronos.dropAll()\n\n    delay(1000 * 60 * 7)\n}\n\nobject SayHello : Job {\n    override val name: String\n        get() = \"say-hello\"\n\n    override val retries: Int\n        get() = 2\n\n    override suspend fun execute(cycleNumber: Int, params: Map&lt;String, Any&gt;): Boolean {\n        super.execute(cycleNumber, params)\n        println(\"Hello ${params[\"firsName\"]} ${params[\"lastName\"]} $cycleNumber\")\n        return true\n    }\n\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Kronos is pushed to MavenCentral repository as kotlin multiplatform library.</p> Kotlin Gradle ScriptGradleMaven <p>Add Maven Central repository:</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> <p>Add dependencies:</p> <pre><code>implementation(\"com.funyinkash:kronos:$latest\")\n</code></pre> <p>Add Maven Central repository:</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> <p>Add dependencies (you can also add other modules that you need):</p> <pre><code>implementation 'com.funyinkash:kronos:$latest'\n</code></pre> <p>Add Maven Central repository to section:</p> <pre><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;central&lt;/id&gt;\n        &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> <p>Add dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.funyinkash&lt;/groupId&gt;\n    &lt;artifactId&gt;kronos&lt;/artifactId&gt;\n    &lt;version&gt;$latest&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"installation/#targets","title":"Targets","text":"<p>Specific dependencies. The Multiplatform dependency above should be sufficient, but these are also published </p> jvmjsandroidlinuxios <pre><code>implementation(\"com.funyinkash:kronos-jvm:$latest\")\n</code></pre> <p>Comming soon</p> <p>Comming soon</p> <p>Comming soon</p> <p>Comming soon</p>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#starting-kronos","title":"Starting Kronos","text":"<p>Kronos should be initialized once through the lifecycle of your application.</p> <p><pre><code>val mongoClient: MongoClient = MongoClient.create(\"mongodb://localhost:27017\")\nval redisClient: RedisClient = RedisClient.create(\"redis://localhost:6379\")\nval connection: StatefulRedisConnection&lt;String, String&gt; = redisClient.connect()\n\nKronos.init(mongoClient = mongoClient, redisConnection = connection)\n</code></pre> Throws IllegalState Exception on attempt to initialize a second time</p>"},{"location":"quick_start/#job","title":"Job","text":"<p>Jobs are categories of tasks that are use to define execution.</p>"},{"location":"quick_start/#define-job","title":"Define Job","text":"<pre><code>object SayHello : Job {\n    override val name: String\n        get() = \"say-hello\"\n\n    override suspend fun execute(cycleNumber: Int, params: Map&lt;String, Any&gt;): Boolean {\n        super.execute(cycleNumber, params)\n        println(\"Hello ${params[\"firsName\"]} ${params[\"lastName\"]} $cycleNumber\")\n        return true\n    }\n}\n</code></pre>"},{"location":"quick_start/#register-job","title":"Register Job","text":"<pre><code>Kronos.register(SayHello)\n</code></pre>"},{"location":"quick_start/#schedule-job","title":"Schedule Job","text":"<p>This Job will start in 1 minute and run once</p> <pre><code>Kronos.schedule(\n        SayHello.name,\n        startTime = Instant.now().plusSeconds(60).toEpochMilli(),\n        params = mapOf(\n            \"firsName\" to \"Funyin\",\n            \"lastName\" to \"Kash\"\n        ),\n    )\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Here is an unordered list of features that I would like to see in kjob. If you consider one of them important please open an issue.</p> <ul> <li>InMemory Kronos : Use TestContainers<ul> <li>Non-persistent in memory variant to serve as a replacement for tests </li> </ul> </li> <li>Backoff retry algorithm for failed jobs<ul> <li>An algorithm to control the retry delay between failed executions</li> </ul> </li> <li>Dashboard <ul> <li>A standalone self hosted application that can provide a ui(kobweb) to display, log and manage jobs. </li> <li>Authentication will be handled by time based randomly updating values in the db. If you have access to those values(your db). Then you are authorized to access the UI</li> </ul> </li> </ul>"},{"location":"why_how/","title":"Why, How","text":""},{"location":"why_how/#the-philosophy-of-kronos","title":"The Philosophy of Kronos","text":"<p>Kronos was developed out of the need for a simple framework agnostic job scheduling tool in kotlin. There were some options but they didn't fit my use case because most of them were written in java or for spring.</p> <p>Here are some examples and why they didn't work for my use-case</p> <ul> <li>Quartz :<ul> <li>Uses Java threads instead of coroutines witch is fine but didn't match my preference.</li> <li>Uses a relational database for persistence, I wanted to use mongodb</li> <li>Didn't have a caching layer over the db</li> </ul> </li> <li>Timer: The   timer from the kotlin standard library<ul> <li>Was not persistent</li> <li>Job status cannot be checked after scheduling</li> </ul> </li> <li>Cron4J: A scheduler for the Java platform which is very similar to   the UNIX cron daemon<ul> <li>Java</li> <li>I am not very familiar with cron jobs</li> <li>Not Observable</li> </ul> </li> <li>Spring Schedule<ul> <li>Dependent on the spring framework</li> </ul> </li> <li>KJob: A lightweight coroutine based persistent job/cron scheduler written in Kotlin<ul> <li>Seemed like the perfect fit, Kotlin, Coroutines and Mongodb but I encountered an error that I could not resolve</li> <li>The last commit was 3 years ago</li> </ul> </li> </ul> <p>After my last try with kJob I decided to attempt creating mine and took some inspiration from it.</p> <p>Documentation format inspired by Quartz, KGraphql and powered by Material for MkDocs</p>"},{"location":"why_how/#how","title":"How","text":"<p>Kronos is a really light weight library with only a few files. The hard part was figuring out the expected execution for a job after the server has been restarted and that's when the Job Registration pattern of KJob made sense.</p> <p>Next was the frequency of checks, a regular heartbeat is required to run schedules.</p> <p>Two options:</p> <ul> <li>Delay the coroutine until the start time of the Job for each Job. Less strain on the system but the time control becomes quite coarse and hard to manage</li> <li>Delay the coroutine by the smallest measure that the system can manage and that jobs will not be lost between ticks. e.g If the job is set to start in 3 minutes and the  tick interval is 2 minutes or 5 minutes, some jobs will fall through. I cam to the conclusion that the smallest possible tick is 1 minute to achieve fine time control.  This created two constraints<ul> <li>The constraint of the smallest possible interval to be 1 minute and the smallest possible time unit to be minutes i.e you won't be able to schedule something for a second. <ul> <li>This I can live with. (Please make use of the Kotlin timer API if you are constrained by this)</li> </ul> </li> <li>The system will hit the db every minute, which will definitely cause a spike in cost<ul> <li>I catered for this by adding a caching layer over the db calls using KacheController</li> </ul> </li> </ul> </li> </ul> <p>The rest is magic, just added some utility callbacks and functions for observing and managing a job</p>"},{"location":"community/","title":"Community","text":"<p>Kronos is nice, contribute and make yourself happy</p>"},{"location":"community/#community-resources","title":"Community Resources","text":"<p>Find and Give Help</p> <ul> <li>Kronos Forum (coming soon)</li> </ul>"},{"location":"community/#report-issues-request-features-get-code","title":"Report Issues, Request Features, Get Code","text":"<ul> <li>Kronos issue tracker</li> <li>Kronos source code repository</li> </ul>"},{"location":"community/contributing/","title":"Contribute","text":""},{"location":"community/contributing/#welcome-aboard","title":"Welcome aboard!","text":"<p>Forget commit access! You can be a Kronos demigod by squishing bugs, crafting docs, and slaying forum monsters.</p>"},{"location":"community/contributing/#recognition","title":"Recognition","text":"<p>We honor all contributors, big or small, by listing them on the development team and displaying them on the documentation home page.</p> <p>Recognition for specific code or documentation authorship ensures proper credit where it's due.</p>"},{"location":"community/contributing/#submitting-contributions","title":"Submitting Contributions","text":"<p>Built something awesome for/with Kronos?</p> <p>Share it! Hit the forums, create a pull request, or just let us know. We love contributions in all shapes and sizes. \ud83d\ude80</p> <p>If you used Kronos in a special use case or project you can raise a pull request to the examples doc and we'll  include it and give you a shout-out</p>"},{"location":"examples/","title":"Index","text":""},{"location":"examples/#examples","title":"Examples:","text":"<p>Here are some examples to get you started or find some that fit your use-case</p> <ul> <li>Scheduling a Job</li> <li>Dropping Jobs</li> <li>Scheduling recursive on time Jobs</li> <li>Defining a Job</li> <li>Challenge Job Execution</li> <li>Retrying Failed Jobs</li> <li>Listening For Loaded Periodic Jobs</li> <li>Schedule a Job for every minute</li> <li>Schedule a Job for every hour at minute</li> <li>Schedule a Job for every 32 minutes</li> <li>Schedule a Job for every Day at hour,minute</li> <li>Schedule a Job for every 2 days</li> <li>Schedule a Job for every week</li> <li>Schedule a Job for every month at day of month &amp; time</li> <li>Schedule a Job for every year at month at day of month &amp; time</li> </ul>"},{"location":"job/","title":"Index","text":""},{"location":"job/#description-jobs","title":"description: \"Jobs\"","text":""},{"location":"job/#job","title":"Job","text":"<p>Jobs are responsible for running and managing tasks. After tasks are scheduled, they are associated with a Job by the name and executed within the Job.</p>"},{"location":"job/#creating-a-job","title":"Creating a Job","text":"<p>To Create a Job you simply Extend the Job Object</p> <pre><code>object SayHello : Job {\n    override val name: String\n        get() = \"say-hello\"\n\n    override suspend fun execute(cycleNumber: Int, params: Map&lt;String, Any&gt;): Boolean {\n        super.execute(cycleNumber, params)\n        println(\"Hello ${params[\"firsName\"]} ${params[\"lastName\"]} $cycleNumber\")\n        return true\n    }\n\n}\n</code></pre> <ul> <li>The cycleNumber is the number of times the job has been executed from 1 -&gt; n</li> <li>The job also provides the params that were provided when the job was scheduled. You can serialize and deserialize objects through this</li> <li>The execution should return <code>true</code> to indicate that the job was successful.</li> </ul>"},{"location":"job/#executing-job","title":"Executing Job","text":""},{"location":"job/#success","title":"Success","text":"<p>Callback for when the job is successful i.e <code>execute</code> returns true <pre><code>object SayHello : Job {\n\n    fun onSuccess(cycleNumber: Int, params: Map&lt;String, Any&gt;) {\n        println(\"KRONOJOB($name) Success: \")\n        println(\"cycle-&gt; $cycleNumber\")\n        println(\"params-&gt; $params\")\n        println(\"time-&gt; ${LocalDateTime.now()}\")\n        println()\n    }\n\n}\n</code></pre></p>"},{"location":"job/#failure","title":"Failure","text":"<p>Callback for when the job is fails i.e <code>execute</code> returns false. This is only called for the first failure.  If it fails again then <code>onRetryFail</code> is called <pre><code>object SayHello : Job {\n\n    fun onFail(cycleNumber: Int, params: Map&lt;String, Any&gt;) {\n\n    }\n\n}\n</code></pre></p>"},{"location":"job/#retries","title":"Retries","text":"<p>In the case that <code>false</code> is returned(i.e task failed) you have the opportunity to set a number of retries with</p> <pre><code>object SayHello : Job {\n    ...\n\n    override val retries: Int\n        get() = 2\n    ...\n}\n</code></pre> <p>This will rerun the execution without any delay for the specified number of retries until the execution returns true. This call back is also provided for each failure</p> <pre><code>object SayHello : Job {\n\n    fun onRetryFail(retryCount: Int, cycleNumber: Int, params: Map&lt;String, Any&gt;) {\n\n    }\n}\n</code></pre>"},{"location":"job/#challenge-execution","title":"Challenge Execution","text":"<p>If the Job has passed the internal execution by kronos and is about to run,  you can prevent it from running by adding your own validation. e.g A Job that runs every day, but you don't want the Job to run if it is a public holiday.</p> <p>The Job will not run if <code>challengeRun</code> returns true</p> <pre><code>object SayHello : Job {\n\n    //This Job will not run if the cycle is an even number\n    fun challengeRun(cycleNumber: Int, params: Map&lt;String, Any&gt;): Boolean {\n        return cycleNumber % 2 == 0\n    }\n}\n</code></pre>"},{"location":"job/#periodic-job-loaded","title":"Periodic Job Loaded","text":"<p>This is called when the next job for a periodic job is scheduled. In case you are making use of the job Id when you scheduled the job, you can listen to this to update the Id  you are referencing</p> <pre><code>object SayHello : Job {\n\n    //This Job will not run if the cycle is an even number\n    fun periodicJobLoaded(originJobId: String, nextJobId: String) {}\n}\n</code></pre>"},{"location":"job/runner/","title":"Runner","text":"<p>The Runner is responsible for managing the validation and execution of jobs after they have been scheduled.</p> <p>There are a few edge cases that you can cater for by directing the runner on what to do in those cases</p> <ol> <li>What happens when the runner comes across a job that was scheduled to be executed in the past but did not get    executed e.g The server    was down at the time</li> <li>What happens when multiple instances of kronos(microservices) are trying to run jobs. Although this is not    recommended, you should delegate this a single service</li> </ol>"},{"location":"job/runner/#1-overshot-action","title":"1. OverShot Action","text":"<p>How you want Kronos to handle a Job when it is over due is termed <code>OvershotAction</code>.</p> <p>There are three Options:</p> <ul> <li>Fire :  The Job is Run immediately without any validation</li> <li>Drop :  The Job is dropped immediately</li> <li>Nothing : No things happens. This is not recommended because it can bloat your db if not handled properly</li> </ul>"},{"location":"job/runner/#2-locks","title":"2. Locks","text":"<p>This is just a failsafe to prevent multiple instances of kronos(in the case of microservices) from running the same job. Once execution on a job starts, the job is locked and prevents other instances from running it</p>"}]}